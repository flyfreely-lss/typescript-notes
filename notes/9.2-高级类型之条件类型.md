# é«˜çº§ç±»å‹ä¹‹æ¡ä»¶ç±»å‹

æœ‰æ—¶å€™æˆ‘ä»¬å¹¶ä¸èƒ½åœ¨ç¼–å†™ä»£ç çš„æ—¶å€™å°±æŠŠç±»å‹ç¡®å®šï¼Œé‚£ä¹ˆè¿™ä¸ªæ—¶å€™éœ€è¦ç”¨åˆ°æ¡ä»¶ç±»å‹äº†ã€‚

> TypeScript åœ¨2.8ç‰ˆæœ¬ä¹‹åå¼•å…¥äº†æ¡ä»¶ç±»å‹(conditional type).

## 1. è¯­æ³•

```typescript
T extends U ? X : Y
```

æ¡ä»¶ç±»å‹ï¼Œ**åªæœ‰ç±»å‹ç³»ç»Ÿä¸­ç»™å‡ºå……è¶³æ¡ä»¶ä¹‹åï¼Œå®ƒæ‰èƒ½æ ¹æ®æ¡ä»¶æ¨æ–­å‡ºç±»å‹ç»“æœ**ã€‚

## 2 ä½¿ç”¨ğŸŒ°

```typescript
declare function f<T extends boolean>(x: T): T extends true ? string : number;
const func5 = f(Math.random() < 0.5);
const func6 = f(true);
const func7 = f(false);
```

func5ã€func6ã€func7çš„ç±»å‹åˆ†åˆ«å¦‚ä¸‹ï¼š

![func5](./images/func5.png)

![func6](./images/func6.png)

![func7](./images/func7.png)

## 3 **æ¡ä»¶ç±»å‹ä¸è”åˆç±»å‹**

æ¡ä»¶ç±»å‹æœ‰ä¸€ä¸ªç‰¹æ€§ï¼Œæ˜¯**åˆ†å¸ƒå¼æœ‰æ¡ä»¶ç±»å‹**ï¼Œ**åˆ†å¸ƒå¼æœ‰æ¡ä»¶ç±»å‹åœ¨å®ä¾‹åŒ–æ—¶ä¼šåˆ†å‘æˆè”åˆç±»å‹**ã€‚

**åˆ†å¸ƒå¼æœ‰æ¡ä»¶ç±»å‹**çš„å‰æï¼šæ¡ä»¶ç±»å‹é‡Œå¾…æ£€æŸ¥çš„ç±»å‹å¿…é¡»æ˜¯ **naked type parameter(è£¸ç±»å‹å‚æ•°).**

### 3.1 æ¦‚å¿µç†è§£

ä¸€ä¸ªä¾‹å­**ğŸŒ°ï¼š**

```
// è£¸ç±»å‹å‚æ•°,æ²¡æœ‰è¢«ä»»ä½•å…¶ä»–ç±»å‹åŒ…è£¹å³T
type NakedUsage<T> = T  extends boolean ? 'YES' : 'NO';
// ç±»å‹å‚æ•°è¢«åŒ…è£¹çš„åœ¨å…ƒç»„å†…å³[T]
type WrappedUsage<T> = [T] extends [boolean] ? "YES" : "NO";

type Distributed = NakedUsage<number | boolean> // = NakedUsage<number> | NakedUsage<boolean> = "NO" | "YES"
// ç­‰ä»·äº
// type Distributed = NakedUsage<number> | NakedUsage<boolean>
```

ä¸Šè¿°ä»£ç ä¸­ï¼Œå½“æˆ‘ä»¬ç»™ç±»å‹NakedUsageåŠ å…¥è”åˆç±»å‹number | booleanæ—¶, å®ƒçš„ç»“æœè¿”å›"NO" | "YES",ç›¸å½“äºè”åˆç±»å‹ä¸­çš„numberå’Œbooleanåˆ†åˆ«èµ‹äºˆäº†NakedUsage<T>ç„¶åå†è¿”å›å‡ºä¸€ä¸ªè”åˆç±»å‹ã€‚

### 3.2 ä½¿ç”¨

éœ€æ±‚ï¼šè®¾è®¡ä¸€ä¸ªç±»å‹å·¥å…·Diff<T, U>,æˆ‘ä»¬è¦æ‰¾å‡ºTç±»å‹ä¸­Uä¸åŒ…å«çš„éƒ¨åˆ†:

type Diff = T extends U ? never : T; type R = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;

è¾“å‡ºï¼š![image](./images/image-2566003.png)

## 4 æ¡ä»¶ç±»å‹ä¸æ˜ å°„ç±»å‹

éœ€æ±‚ï¼šç¼–å†™ä¸€ä¸ªå·¥å…·ç±»å‹å°†interfaceä¸­å‡½æ•°ç±»å‹çš„åç§°å–å‡ºæ¥ã€‚

```
interface Part {
    id: number;
    name: string;
    subparts: Part[];
    updatePart(newName: string): void;
}
type FunctionPropertyNames<T> = { [K in keyof T]: T[K] extends Function ? K : never }[keyof T]
type R1 = FunctionPropertyNames<Part>;
```

è¾“å‡ºï¼š

![image1](./images/image1-2566099.png)

é‡ç‚¹åˆ†æï¼š

1. [K in keyof T] ç›¸å½“äºéå†æ•´ä¸ª interface
2. { [K in keyof T]: T[K] extends Function ? K : never } æ“ä½œåï¼Œå¾—åˆ°çš„æ–°interfaceä¸ºï¼š

```
type R = {
    id: never;
    name: never;
    subparts: never;
    updatePart: "updatePart";
}
```

3. æœ€åä½¿ç”¨ [keyof T] ä½œä¸ºkeyä¾æ¬¡å–å‡ºæ–°interfaceçš„valueï¼Œç”±äºidï¼Œnameï¼Œsubpartsçš„å€¼ä¸ºnever ï¼Œä¸ä¼šè¿”å›ä»»ä½•ç±»å‹ï¼Œæ‰€ä»¥åªè¿”å›äº†'updatePart'ã€‚